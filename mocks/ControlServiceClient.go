// Code generated by mockery v2.51.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	rpcpb "github.com/ava-labs/avalanche-network-runner/rpcpb"
)

// ControlServiceClient is an autogenerated mock type for the ControlServiceClient type
type ControlServiceClient struct {
	mock.Mock
}

// AddNode provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) AddNode(ctx context.Context, in *rpcpb.AddNodeRequest, opts ...grpc.CallOption) (*rpcpb.AddNodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddNode")
	}

	var r0 *rpcpb.AddNodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddNodeRequest, ...grpc.CallOption) (*rpcpb.AddNodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddNodeRequest, ...grpc.CallOption) *rpcpb.AddNodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.AddNodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.AddNodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPermissionlessDelegator provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) AddPermissionlessDelegator(ctx context.Context, in *rpcpb.AddPermissionlessDelegatorRequest, opts ...grpc.CallOption) (*rpcpb.AddPermissionlessDelegatorResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionlessDelegator")
	}

	var r0 *rpcpb.AddPermissionlessDelegatorResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddPermissionlessDelegatorRequest, ...grpc.CallOption) (*rpcpb.AddPermissionlessDelegatorResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddPermissionlessDelegatorRequest, ...grpc.CallOption) *rpcpb.AddPermissionlessDelegatorResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.AddPermissionlessDelegatorResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.AddPermissionlessDelegatorRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPermissionlessValidator provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) AddPermissionlessValidator(ctx context.Context, in *rpcpb.AddPermissionlessValidatorRequest, opts ...grpc.CallOption) (*rpcpb.AddPermissionlessValidatorResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddPermissionlessValidator")
	}

	var r0 *rpcpb.AddPermissionlessValidatorResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddPermissionlessValidatorRequest, ...grpc.CallOption) (*rpcpb.AddPermissionlessValidatorResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddPermissionlessValidatorRequest, ...grpc.CallOption) *rpcpb.AddPermissionlessValidatorResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.AddPermissionlessValidatorResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.AddPermissionlessValidatorRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSubnetValidators provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) AddSubnetValidators(ctx context.Context, in *rpcpb.AddSubnetValidatorsRequest, opts ...grpc.CallOption) (*rpcpb.AddSubnetValidatorsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSubnetValidators")
	}

	var r0 *rpcpb.AddSubnetValidatorsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddSubnetValidatorsRequest, ...grpc.CallOption) (*rpcpb.AddSubnetValidatorsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AddSubnetValidatorsRequest, ...grpc.CallOption) *rpcpb.AddSubnetValidatorsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.AddSubnetValidatorsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.AddSubnetValidatorsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttachPeer provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) AttachPeer(ctx context.Context, in *rpcpb.AttachPeerRequest, opts ...grpc.CallOption) (*rpcpb.AttachPeerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AttachPeer")
	}

	var r0 *rpcpb.AttachPeerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AttachPeerRequest, ...grpc.CallOption) (*rpcpb.AttachPeerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.AttachPeerRequest, ...grpc.CallOption) *rpcpb.AttachPeerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.AttachPeerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.AttachPeerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBlockchains provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) CreateBlockchains(ctx context.Context, in *rpcpb.CreateBlockchainsRequest, opts ...grpc.CallOption) (*rpcpb.CreateBlockchainsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateBlockchains")
	}

	var r0 *rpcpb.CreateBlockchainsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.CreateBlockchainsRequest, ...grpc.CallOption) (*rpcpb.CreateBlockchainsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.CreateBlockchainsRequest, ...grpc.CallOption) *rpcpb.CreateBlockchainsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.CreateBlockchainsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.CreateBlockchainsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSubnets provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) CreateSubnets(ctx context.Context, in *rpcpb.CreateSubnetsRequest, opts ...grpc.CallOption) (*rpcpb.CreateSubnetsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubnets")
	}

	var r0 *rpcpb.CreateSubnetsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.CreateSubnetsRequest, ...grpc.CallOption) (*rpcpb.CreateSubnetsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.CreateSubnetsRequest, ...grpc.CallOption) *rpcpb.CreateSubnetsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.CreateSubnetsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.CreateSubnetsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSnapshotNames provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) GetSnapshotNames(ctx context.Context, in *rpcpb.GetSnapshotNamesRequest, opts ...grpc.CallOption) (*rpcpb.GetSnapshotNamesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnapshotNames")
	}

	var r0 *rpcpb.GetSnapshotNamesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.GetSnapshotNamesRequest, ...grpc.CallOption) (*rpcpb.GetSnapshotNamesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.GetSnapshotNamesRequest, ...grpc.CallOption) *rpcpb.GetSnapshotNamesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.GetSnapshotNamesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.GetSnapshotNamesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Health provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) Health(ctx context.Context, in *rpcpb.HealthRequest, opts ...grpc.CallOption) (*rpcpb.HealthResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 *rpcpb.HealthResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.HealthRequest, ...grpc.CallOption) (*rpcpb.HealthResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.HealthRequest, ...grpc.CallOption) *rpcpb.HealthResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.HealthResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.HealthRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBlockchains provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) ListBlockchains(ctx context.Context, in *rpcpb.ListBlockchainsRequest, opts ...grpc.CallOption) (*rpcpb.ListBlockchainsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBlockchains")
	}

	var r0 *rpcpb.ListBlockchainsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListBlockchainsRequest, ...grpc.CallOption) (*rpcpb.ListBlockchainsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListBlockchainsRequest, ...grpc.CallOption) *rpcpb.ListBlockchainsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.ListBlockchainsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.ListBlockchainsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRpcs provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) ListRpcs(ctx context.Context, in *rpcpb.ListRpcsRequest, opts ...grpc.CallOption) (*rpcpb.ListRpcsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRpcs")
	}

	var r0 *rpcpb.ListRpcsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListRpcsRequest, ...grpc.CallOption) (*rpcpb.ListRpcsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListRpcsRequest, ...grpc.CallOption) *rpcpb.ListRpcsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.ListRpcsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.ListRpcsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSubnets provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) ListSubnets(ctx context.Context, in *rpcpb.ListSubnetsRequest, opts ...grpc.CallOption) (*rpcpb.ListSubnetsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubnets")
	}

	var r0 *rpcpb.ListSubnetsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListSubnetsRequest, ...grpc.CallOption) (*rpcpb.ListSubnetsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ListSubnetsRequest, ...grpc.CallOption) *rpcpb.ListSubnetsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.ListSubnetsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.ListSubnetsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadSnapshot provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) LoadSnapshot(ctx context.Context, in *rpcpb.LoadSnapshotRequest, opts ...grpc.CallOption) (*rpcpb.LoadSnapshotResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadSnapshot")
	}

	var r0 *rpcpb.LoadSnapshotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.LoadSnapshotRequest, ...grpc.CallOption) (*rpcpb.LoadSnapshotResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.LoadSnapshotRequest, ...grpc.CallOption) *rpcpb.LoadSnapshotResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.LoadSnapshotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.LoadSnapshotRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PauseNode provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) PauseNode(ctx context.Context, in *rpcpb.PauseNodeRequest, opts ...grpc.CallOption) (*rpcpb.PauseNodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PauseNode")
	}

	var r0 *rpcpb.PauseNodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.PauseNodeRequest, ...grpc.CallOption) (*rpcpb.PauseNodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.PauseNodeRequest, ...grpc.CallOption) *rpcpb.PauseNodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.PauseNodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.PauseNodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCVersion provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) RPCVersion(ctx context.Context, in *rpcpb.RPCVersionRequest, opts ...grpc.CallOption) (*rpcpb.RPCVersionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPCVersion")
	}

	var r0 *rpcpb.RPCVersionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RPCVersionRequest, ...grpc.CallOption) (*rpcpb.RPCVersionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RPCVersionRequest, ...grpc.CallOption) *rpcpb.RPCVersionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.RPCVersionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.RPCVersionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNode provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) RemoveNode(ctx context.Context, in *rpcpb.RemoveNodeRequest, opts ...grpc.CallOption) (*rpcpb.RemoveNodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNode")
	}

	var r0 *rpcpb.RemoveNodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveNodeRequest, ...grpc.CallOption) (*rpcpb.RemoveNodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveNodeRequest, ...grpc.CallOption) *rpcpb.RemoveNodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.RemoveNodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.RemoveNodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveSnapshot provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) RemoveSnapshot(ctx context.Context, in *rpcpb.RemoveSnapshotRequest, opts ...grpc.CallOption) (*rpcpb.RemoveSnapshotResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSnapshot")
	}

	var r0 *rpcpb.RemoveSnapshotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveSnapshotRequest, ...grpc.CallOption) (*rpcpb.RemoveSnapshotResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveSnapshotRequest, ...grpc.CallOption) *rpcpb.RemoveSnapshotResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.RemoveSnapshotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.RemoveSnapshotRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveSubnetValidator provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) RemoveSubnetValidator(ctx context.Context, in *rpcpb.RemoveSubnetValidatorRequest, opts ...grpc.CallOption) (*rpcpb.RemoveSubnetValidatorResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSubnetValidator")
	}

	var r0 *rpcpb.RemoveSubnetValidatorResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveSubnetValidatorRequest, ...grpc.CallOption) (*rpcpb.RemoveSubnetValidatorResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RemoveSubnetValidatorRequest, ...grpc.CallOption) *rpcpb.RemoveSubnetValidatorResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.RemoveSubnetValidatorResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.RemoveSubnetValidatorRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartNode provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) RestartNode(ctx context.Context, in *rpcpb.RestartNodeRequest, opts ...grpc.CallOption) (*rpcpb.RestartNodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestartNode")
	}

	var r0 *rpcpb.RestartNodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RestartNodeRequest, ...grpc.CallOption) (*rpcpb.RestartNodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.RestartNodeRequest, ...grpc.CallOption) *rpcpb.RestartNodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.RestartNodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.RestartNodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResumeNode provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) ResumeNode(ctx context.Context, in *rpcpb.ResumeNodeRequest, opts ...grpc.CallOption) (*rpcpb.ResumeNodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResumeNode")
	}

	var r0 *rpcpb.ResumeNodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ResumeNodeRequest, ...grpc.CallOption) (*rpcpb.ResumeNodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.ResumeNodeRequest, ...grpc.CallOption) *rpcpb.ResumeNodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.ResumeNodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.ResumeNodeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveSnapshot provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) SaveSnapshot(ctx context.Context, in *rpcpb.SaveSnapshotRequest, opts ...grpc.CallOption) (*rpcpb.SaveSnapshotResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SaveSnapshot")
	}

	var r0 *rpcpb.SaveSnapshotResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.SaveSnapshotRequest, ...grpc.CallOption) (*rpcpb.SaveSnapshotResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.SaveSnapshotRequest, ...grpc.CallOption) *rpcpb.SaveSnapshotResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.SaveSnapshotResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.SaveSnapshotRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendOutboundMessage provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) SendOutboundMessage(ctx context.Context, in *rpcpb.SendOutboundMessageRequest, opts ...grpc.CallOption) (*rpcpb.SendOutboundMessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SendOutboundMessage")
	}

	var r0 *rpcpb.SendOutboundMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.SendOutboundMessageRequest, ...grpc.CallOption) (*rpcpb.SendOutboundMessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.SendOutboundMessageRequest, ...grpc.CallOption) *rpcpb.SendOutboundMessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.SendOutboundMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.SendOutboundMessageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Start provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) Start(ctx context.Context, in *rpcpb.StartRequest, opts ...grpc.CallOption) (*rpcpb.StartResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 *rpcpb.StartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StartRequest, ...grpc.CallOption) (*rpcpb.StartResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StartRequest, ...grpc.CallOption) *rpcpb.StartResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.StartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.StartRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Status provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) Status(ctx context.Context, in *rpcpb.StatusRequest, opts ...grpc.CallOption) (*rpcpb.StatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *rpcpb.StatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StatusRequest, ...grpc.CallOption) (*rpcpb.StatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StatusRequest, ...grpc.CallOption) *rpcpb.StatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.StatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.StatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stop provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) Stop(ctx context.Context, in *rpcpb.StopRequest, opts ...grpc.CallOption) (*rpcpb.StopResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 *rpcpb.StopResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StopRequest, ...grpc.CallOption) (*rpcpb.StopResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StopRequest, ...grpc.CallOption) *rpcpb.StopResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.StopResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.StopRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamStatus provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) StreamStatus(ctx context.Context, in *rpcpb.StreamStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[rpcpb.StreamStatusResponse], error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamStatus")
	}

	var r0 grpc.ServerStreamingClient[rpcpb.StreamStatusResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StreamStatusRequest, ...grpc.CallOption) (grpc.ServerStreamingClient[rpcpb.StreamStatusResponse], error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.StreamStatusRequest, ...grpc.CallOption) grpc.ServerStreamingClient[rpcpb.StreamStatusResponse]); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(grpc.ServerStreamingClient[rpcpb.StreamStatusResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.StreamStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransformElasticSubnets provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) TransformElasticSubnets(ctx context.Context, in *rpcpb.TransformElasticSubnetsRequest, opts ...grpc.CallOption) (*rpcpb.TransformElasticSubnetsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TransformElasticSubnets")
	}

	var r0 *rpcpb.TransformElasticSubnetsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.TransformElasticSubnetsRequest, ...grpc.CallOption) (*rpcpb.TransformElasticSubnetsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.TransformElasticSubnetsRequest, ...grpc.CallOption) *rpcpb.TransformElasticSubnetsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.TransformElasticSubnetsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.TransformElasticSubnetsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// URIs provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) URIs(ctx context.Context, in *rpcpb.URIsRequest, opts ...grpc.CallOption) (*rpcpb.URIsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for URIs")
	}

	var r0 *rpcpb.URIsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.URIsRequest, ...grpc.CallOption) (*rpcpb.URIsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.URIsRequest, ...grpc.CallOption) *rpcpb.URIsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.URIsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.URIsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStatus provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) UpdateStatus(ctx context.Context, in *rpcpb.UpdateStatusRequest, opts ...grpc.CallOption) (*rpcpb.UpdateStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 *rpcpb.UpdateStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.UpdateStatusRequest, ...grpc.CallOption) (*rpcpb.UpdateStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.UpdateStatusRequest, ...grpc.CallOption) *rpcpb.UpdateStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.UpdateStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.UpdateStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VMID provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) VMID(ctx context.Context, in *rpcpb.VMIDRequest, opts ...grpc.CallOption) (*rpcpb.VMIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VMID")
	}

	var r0 *rpcpb.VMIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.VMIDRequest, ...grpc.CallOption) (*rpcpb.VMIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.VMIDRequest, ...grpc.CallOption) *rpcpb.VMIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.VMIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.VMIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitForHealthy provides a mock function with given fields: ctx, in, opts
func (_m *ControlServiceClient) WaitForHealthy(ctx context.Context, in *rpcpb.WaitForHealthyRequest, opts ...grpc.CallOption) (*rpcpb.WaitForHealthyResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WaitForHealthy")
	}

	var r0 *rpcpb.WaitForHealthyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.WaitForHealthyRequest, ...grpc.CallOption) (*rpcpb.WaitForHealthyResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *rpcpb.WaitForHealthyRequest, ...grpc.CallOption) *rpcpb.WaitForHealthyResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcpb.WaitForHealthyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *rpcpb.WaitForHealthyRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewControlServiceClient creates a new instance of ControlServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewControlServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *ControlServiceClient {
	mock := &ControlServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
